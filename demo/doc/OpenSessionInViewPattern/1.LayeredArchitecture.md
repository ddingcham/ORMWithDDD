# 레이어 아키텍처(Layered Architecture)  

## 기본 아이디어  
#### UI와 Persistence Mechanism을 포함하는 대부분의 EA는 Layered Architecture 패턴 기반

* 시스템을 유사한 책임을 지닌 레이어로 분해  
* 각각의 레이어가 하위의 레이어에만 의존하도록 시스템을 구성  

### Relaxed Layered System   
현대적인 엔터프라이즈 어플리케이션의 일반적인 구조  

* 각각의 레이어가 바로 하위 레이어에만 의존해야 한다는 제약 완화  
* layering through inheritance (상속을 통한 레이어 구성)  
  > 프레임워크의 인터페이스나 클래스를 상속 받아 애플리케이션의 핵심 클래스를 구현  
  > 침투적  
  
### 목적 - 관심사의 분리 (Separation of Concerns)
#### // 낮은 결합과 높은 응집  

* Frank Buschman, Pattern-Oriented Software Architecture Vol. 1  
  * 서로 다르고 관련이 없는 책임(responsibility)들은 소프트웨어 내에서 서로 분리해야 함  
  * 특정 태스크의 해결을 위해 매진하는 협력(collaboration) 컴포넌트들은 다른 태스크의 작업에
    사용되는 컴포넌트들로부터 분리되어야 한다.  
  * 정황(Context)이 다를 때마다 각각 다른 역할들을 담당하는 컴포넌트가 있다면,  
    해당 컴포넌트 내에서 역할들은 독립적으로 분리되어야 한다.  
  
  * 자료 예  
    ```
    Model - View - Controller 패턴은 역할을 내부적으로
    모델, 사용자 프레젠테이션, 입력 처리로 분리한다.
    ```
    
### 대부분의 어플리케이션의 레이어들  
* User Interface Layer  
  > 사용자 화면 구성  
* Application Layer  
  > 애플리케이션의 제어 흐름 관리  
* Domain Layer  
  > 도메인의 핵심 로직 포함  
* Infrastructure Layer  
  > 상위 계층 지원  
  
## 일반적인 레이어 분리 원칙  

### Model-View Separation _ Fowler PEAA, Larman AUP  
* 도메인 로직과 사용자 인터페이스는 서로 다른 관심사를 다룬다.  
  #### 따라서 모델(도메인 로직 관심사)과 뷰(사용자 인터페이스 관심사)는 별도의 레이어로 분리  
  * 모델은 화면 출력과 관련된 로직을 포함해서는 안된다  
  * 뷰는 비즈니스 로직을 포함해서는 안된다  

* **가장 중요한 것은 의존성의 방향**  
  * 뷰는 모델에 의존할 수 있다.  
    > 사용자 인터페이스 레이어에서 도메인 레이어로의 접근은 허용  
  * **모델은 뷰에 의존할 수 없다.**  
    > 도메인 레이어에서 사용자 인터페이스로의 접근은 허용  
    
```
모델(도메인)이 화면에 표현될 경우의 수에 대한 책임을 지녀야 하나?
인프라 스트럭처가 그 책임을 담당하면 어떻게 되나?
엔티티의 상태에 대한 문제가 아닌 엔티티 객체 그래프를 얼마나 꺼내 올꺼냐의 문제니까  
```

### Clean and Thin View _ Johnson J2EEDD  
* Clean View  
  > 뷰는 오직 마크업과 화면 출력 로직만을 포함해야 한다.  

* Thin View  
  > 뷰는 시스템의 상태를 변경시킬 수 있는 비즈니스 로직을 포함해서는 안 된다.    
  
### PI, Persistence Ignorance _ Nilsson ADDD  
모델과 뷰가 서로 다른 관심사를 다루는 것과 마찬가지로  
#### 도메인 로직과 영속성 로직 역시 서로 다른 관심사를 다룬다.  

* 영속성 메커니즘은 도메인 객체에 의존  
* 도메인 객체는 영속성 메커니즘으로부터 독립적  
* 일반적인 방법  
  * 도메인 객체를 데이터베이스 관련 인프라스트럭처에 독립적인 POJO로 개발  
  * DAO 패턴(Data Access Object _ Alur CORE)을 이용해서 인터페이스 하부로  
    영속성 메커니즘을 캡슐화  
    > 영속성 메커니즘의 세부 구현 정보가 외부에 노출되지 않도록  
  
### Domain Layer Isolation _ Evans DDD  
#### 비즈니스를 구성하는 핵심 개념과 중요한 정보  
#### 준수해야하는 비즈니스 규칙을 표현  

* 시스템을 단순하고 유연한 상태로 유지  
  * 도메인 레이어를 기술적인 이슈로부터 고립  
    * **소프트웨어 개발에서 진정한 복잡함이 발생하는 장소**
    * **우리는 요구사항 변경을 환영**
    #### 해당 복잡함에만 집중할 수 있도록 최대한 격리시켜야 한다.
    > 격리 시켜놓고, 부가적인 관심사를 고려하지 말자.  

#### "모델 뷰 분리", "영속성 분리"를 통해 달성하고자 하는 궁극적 목표  
#### -> Domain Layer Isolation  


## 실제적인 가치 - Domain Layer  
### 문제의 원인  
* 사용자측 문제  
  > 사용자 인터페이스로 비즈니스 로직이 누수  
* 서버측 문제  
  > 애플리케이션 로직이 외부 데이터베이스나 타 서비스와 강하게 결합  
  #### 모두 실제로는 설계와 프로그래밍 상에서의 동일한 오류로 인한 것  
  #### 결합 시킨 상태에서는 아무리 고민해봤자 문제는 해결되지 않았음  
  
### 외부 엔티티와의 상호작용과 비즈니스 로직간의 결합  
* 관점을 바꾸자  
  * 잘못된 관점  
    > 애플리케이션의 왼쪽(UI), 오른쪽(DB)  
  * 우리가 봐야 할 관점  
    > 애플리케이션의 내부(도메인 레이어), 외부(UI와 DB)  
  #### 중요한 원칙 : "내부"에 존재하는 코드는 "외부"로 누수되어서는 안된다.  
    
### 도메인 레이어에 도메인과 무관한 기술적인 이슈가 침투할수록 시스템을 변경하고 이해하기 어려워 진다.  
* 복잡한 프로그램을 여러 개의 계층으로 분할하라  
* 응집력 있고 오직 하위의 계층에만 의존하는 각 계층에서 설계를 발전시켜라  
* 표준 아키텍처 패턴에 따라 상위 계층과의 결합은 느슨하게 유지하라  
* 도메인 모델에 관계된 코드는 모두 한 계층에 모아라  
  * 사용자 인터페이스 코드  
  * 애플리케이션 제어 코드  
  * 인프라스트럭처 코드  
  #### 해당 계층에는 위 세가지를 모두 격리하라  
  
* 자유로운 도메인 객체  
  > 도메인 모델의 표현에만 집중할 수 있도록 설계  
  * 화면에 표시 및 저장 책임 격리  
  * 애플리케이션 흐름 관리 책임 격리  
  
#### 격리된 도메인은 지속적인 진화에 유리하다.
#### 모델(도메인)은 업무의 본질적인 지식만을 포착한다.
#### 모델(도메인)은 해당 업무 지식을 적용시킬 수 있을 정도로
#### 풍부하고 명확해질 것이다. (표현적 차이가 줄어들 것이다)

