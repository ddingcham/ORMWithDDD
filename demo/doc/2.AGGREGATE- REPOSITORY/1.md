# [Domain-Driven Design의 적용 - 2.AGGREGATE와 REPOSITORY 1부](http://aeternum.egloos.com/1144679)

## 주문 도메인

### 기본적인 도메인 모델
![주문 도메인 모델](http://pds12.egloos.com/pds/200811/20/18/f0081118_4924fee94926b.jpg "주문 도메인 모델")  
* 고객(Customer)은 시스템을 사용해서 상품을 주문(Order)한다.  
* 한 번 주문 시 다수의 상품(OrderLineItem)을 구매할 수 있다.  
* 상품에 대한 이름(name), 가격(price)과 같은 기본 정보는 별도의 상품(Product) 클래스에 정의한다.    
* 고객은 고객 등급에 따라 일 회 주문 시 구매 가능한 금액에 제한(limitPrice 프로퍼티)를 받는다.  


### **도메인 모델의 표현과 효율성** 관점에서의 REFERENCE OBJECT 와 VALUE OBJECT
* Customer 클래스와 Money 클래스 표기  
  * REFERNCE OBJECT는 독립적인 클래스로 표기  
  * VALUE OBJECT는 클래스의 속성으로 표기  
> 좋은 모델이란 충분한 정보를 다루면서도  
> 세부 사항에 집착하지 않고, 핵심 주제를 효과적으로 전달 // Implementation hiding ?!  
  
* 주문 도메인의 핵심 주제  
  * 고객(Customer)  
  * 주문(Order)  
  * 주문 항목(OrderLineItem)  
  * 상품(Product)
> 위 개념들과 개념들 간의 상호 관계가 핵심 주제  
> 상대적으로 중요도가 낮은 금액(Money)을 프로퍼티로 표현함으로써,  
> 경제적이면서도 의미 전달이 명확한 모델을 만들 수 있다.

#### 잘못된 예와 의미전달의 효율성 // 핵심 주제가 무엇인가?
![비경제적인 모델 예시](http://pds10.egloos.com/pds/200811/20/18/f0081118_4924ff3ab76fd.jpg "비경제적인 모델")
> 핵심 주제가 강조될 수 있도록 하자! // 대상들을 **분류**

### **주문 행위**에 대한 **주도권**
주문 시 고객은 정해진 한도 내에서 상품을 구매할 수 있다.  
한도 초과 여부를 검증하는 책임을 어떤 도메인 객체에게 할당해야 할까?  

#### 주장 1] 고객(Customer) 객체에게 할당
주장 1] 주문 한도(limitPrice)를 알고 있는 고객 객체가 초과 한도를 검증해야 한다.

* 양방향 연관 관계 발생  
  한도액을 초과 여부를 검증하기 위해서는 주문 한도(limitPrice)뿐만 아니라,
  주문(Order) 객체의 내부 상태를 알아야한다.  
  > 결과적으로 고객과 주문 간에 양방향 연관 관계를 발생시킨다.
  
  양방향 연관 관계는 왠만하면 지양  
  * 양방향 연관 관계는 도메인 모델 간의 **결합도**를 높힌다.  
  * 관계간의 일관성을 유지하기 위해 필요한 **구현 복잡도**를 증가시킨다.
  
* 기능에 대한 욕심 (Feature Envy) // Bad Smell  
: 메소드가 자신의 내용보다 다른 클래스의 내용에 더 관심을 가질 경우 나타나는 나쁜 냄새  
  고객(Customer) 객체가 자신이 몰라도 상관없는 주문의 상세 정보까지 눈독을 들임으로써 객체 간의 결합도가 높아진다.  
  > 정보를 가지고 있는 클래스에 해당 행위에 대한 책임을 할당하라는 INFORMATION EXPERT 패턴에 위반된다.
  [INFORMATION EXPERT 패턴](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Information_expert)

#### 주장 2] 주문(Order) 객체에게 할당

* 기존 연관 관계 설정 준수 // 맨 위 도메인 모델 참고  
  한도액 검증을 위해서는 고객 객체의 주문 한도액(limitPrice)을 알아야 한다.  
  이미 주문 객체에서 고객 객체로의 연관 관계가 설정되어 있기 때문에,  
  새로운 연관 관계(양방향 연관 관계를 발생시키는)를 추가하지 않고도 주문 한도액을 검증할 수 있다.
  
* 객체의 책임 할당 관점  // 낮은 결합도와 높은 응집력 (Low Coupling, High Cohesion) 준수  
  주문에 포함된 정보를 사용하여 한도를 검증  
  * 기능에 대한 욕심(Feature Envy) 방지  
  * INFORMATION EXPERT 패턴 준수
  
> 한도액 검증 책임은 "주장 2]"에게 할당하는 것이 적절
  
### **주문**에 대한 고려대상들

#### **주문** 시나리오  

// **시스템**의 역할도 생각해 보자.  
// => 프레임워크, 컨테이너가 우리에게 제공하는 가치를 어떻게 받아들일지 느낌이 옴    

1) 고객은 상품을 선택하고 상품의 개수를 입력한다.  
2) 시스템은 상품과 개수를 가진 주문 항목을 생성하고 주문에 추가한다.  
3) 주문은 새로 추가된 주문 항목의 가격을 더한 주문 총액과 구매 고객의 한도액을 비교한다.  
4) 만약 한도를 초과했다면 예외를 발생시키고 주문 프로세스를 중단한다.  

#### 불변식(invariant) // 변하지 않는 것

* 시나리오 속 불변식(invariant)  
  * 주문 시 한도액을 검증하기 위해서는 주문 객체와 주문 항목 객체 간의 긴밀한 협력이 필요하다.  
  * 상태 변경 시 이들이 하나의 단위로 취급 되어야 한다.  
  > 주문 객체와 주문 항목 객체들은 구매액이 고객의 주문 한도액을 초과할 수 없다는  
  > 불변식(invariant)을 공유하는 하나의 논리적 단위  

* 불변식(invariant)의 유지  
  * 주문과 주문 항목 간의 불변식을 유지하기 위해서는,  
  주문에 주문 항목이 추가된 이후에도 외부에서 직접적으로 주문 항목을 수정할 수 없도록 해야한다.  
  
  * 외부에서 주문을 우회해서 주문 항목의 상태를 임의로 변경할 수 있다면,  
  한도액에 관한 불변식을 유지하는 것이 불가능해진다.  
  
  > 주문 항목(OrderLineItem)은 외부에 노출되지 않아야 한다.  
  > 주문 항목(OrderLineItem)의 추가, 수정, 삭제는 반드신 주문의 제어 하에 수행되어야 한다.  
  > 결론 : 주문(Order)은 주문 항목(OrderLineItem)을 캡슐화해야 한다.
  
### **동시성 관리**
* 주문과 주문 항목 클러스터에 상품(Product) 객체를 포함시킬 수 있을까?  
* 상품 객체 역시 고객 객체처럼 주문-주문 항목 클러스터의 외부 객체로 보야할까?  
> 문제 논의를 위해 실행 컨텍스트를 멀티 쓰레드 환경으로 확장

#### 다중 사용자(멀티 쓰레드) 환경에서의 **동시성** 이슈
```
두 사용자(A, B)의 요청이 거의 동시에 들어오고,
단일 프로세서를 탑재한 시스템 상에서 각각 다른 쓰레드로 처리될 때 발생할 수 있는 상황 

1. 불변식 검증
1-1. A의 수정 요청에 대한 불변식 검증을 통과
// 바로 컨텍스트 스위칭 발생
1-2. B의 수정 요청에 대한 불변식 검증 역시 통과

2. 수정 내역 반영
2-1. A의 요청에 대한 불변식 검증이 통과 되었으므로 주문에 반영
2-2. B의 요청에 대한 불변식 검증 역시 통과 되었으므로 주문에 반영
```

* 주문에 대한 간접적인 **불변식** 위반이 발생한다.  
  각각의 사용자 입장에서는 지켜졌지만 .....
* 전체 시스템 관점에서의 **무결성** 개념이 무너진다.  

#### 동시성 문제로 인한 불변식 위반의 방지 // Transaction 관리
"주문-주문 항목" 클러스터에 대한 **배타적인 접근**이 가능해야 한다.

* 주문(Order) 관점  
  * 첫 번째 요청(A)이 주문(Order)을 얻을 때, 다른 사용자가 동일한 주문(Order)을 얻을 수 없도록 lock  
  * 두 번째 요청(B)은 첫 번째 요청(A)의 lock이 해제될 때까지 대기  
  > "주문-주문 항목" 전체가 잠기기 위해서는 B가 주문을 우회해서 주문 항목에 접근하는 경우는 없어야 한다.  
  > 따라서, 주문 항목은 항상 주문을 통해서만 접근 가능해야 한다.

* 상품(Product) 관점  
  주문 항목과 연관된 상품(Product) 객체 역시 lock을 설정하여 배타적인 접근이 가능하도록 해야 할까?  
  * 주문 항목(OrderLineItem)은 각 주문(Order)의 일부이며 하나의 주문에 의해서만 참조된다.  
    > 주문(Order)과 함께 잠기더라도 시스템의 성능에 영향을 미치지 않는다.  
    
  * 상품(Product)는 하나 이상의 주문(Order)에 의해 참조된다.    
![같은 상품에 접근하는 다른 주문들](http://thumbnail.egloos.net/600x0/http://pds11.egloos.com/pds/200811/20/18/f0081118_49250033471f9.jpg  "같은 상품에 접근하는 다른 주문들")

    > 상품은 주문과 주문 항목과 달리 높은 빈도의 경쟁(high contention)이 발생하는 객체이다.
    > 주문(Order)을 잠글 때마다 연결된 모든 상품(Product)를 함께 잠근다면,  
    > 해당 상품(Product)에 접근하려는 모든 주문(Order) 객체가 동시에 대기 상태로 빠지게 된다.
    
  * 변경 빈도 (the frequency of change)  
  주문과 주문 항목이 변경되는 빈도에 비해 상품의 변경 빈도(the frequency of change)는  
  상대적으로 매우 낮다.  
  
  > 일반적인 주문 비즈니스 관점에서  
  > 주문과 주문 항목은 매우 빈번하게 생성, 수정, 삭제 된다.  
  > 상품의 명칭 및 가격의 수정, 신규 상품의 추가, 상품의 삭제는 빈번하게 발생하지 않는다.  
  
  > 주문과 주문 항목의 수정은 거의 비슷한 시점에 발생한다.  
  > 상품의 수정 시점은 주문, 주문 항목의 수정 시점과는 무관하다.
  
* 결론] AGGREGATE   
  * 주문, 주문 항목은 하나의 객체 클러스터를 구성한다.  
  * 고객, 상품은 주문 클러스터에 속하지 않는 독립적인 객체로 존재한다.  
  
  > 변경에 대한 불변식을 유지하기 위해 하나의 단위로 취급하고,  
  > 변경의 빈도가 비슷하고,  
  > 동시 접근에 대한 작금의 단위가 되는 객체의 집합을 AGGREGATE라고 한다.  
  
![AGGREGATE](http://pds11.egloos.com/pds/200811/20/18/f0081118_492500615afbc.jpg "AGGREGATE")
