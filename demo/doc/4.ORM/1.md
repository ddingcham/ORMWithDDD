# [Domain-Driven Design의 적용 - 4.ORM과 투명한 영속성 1부](http://aeternum.egloos.com/1366968)

## 도메인 모델과 소프트웨어 모델  

### 현재의 산출물까지 ...  

* **고객이 주문 시스템을 원한다.**  
  * UML  
    > 구현 명세가 아닌 설계 스케치 용도  
    > 고객과 개발자 간의 회의 시 커뮤니케이션 도구  
    > **UML 문법이 아닌, 시스템에 반영될 도메인 개념과 개념들 간의 관계에 집중**

    * 클래스와 속성, 책임에 사용되는 용어들  
      > **고객**들이 업무에서 실제로 쓰고 있는 용어를 그대로 사용  
      > **속성, 메소드**를 할당 할 때도 **고객의 용어**를 사용  
      > 존재하지 않는다면, 고객과의 토의를 통해 선정된 적절한 용어를 사용  
      
  * RDBMS  
  > 도메인 정보의 영속성 보장을 위해 도입  
  
    * 결합도 최소화  
      * Spring의 Dependency Injection 활용  
      * Repository의 EXTRACT INTERFACE를 통한 데이터베이스 로직 캡슐화  
    > 데이터 베이스 접근 코드에 의한 파급 효과 제한과 테스트 용이성 보장  
    
### 중요한 것  
**고객이 주문 시스템을 원한다.**  
* 도메인 모델은 고객의 용어로 말하고, 고객의 의도대로 행동한다.  
  * 도메인 모델은 도메인에 관해서 이야기한다.  
  > 도메인과 무관한 기술적인 부분에 관해서는 이야기 하지 않는다.

> 분석, 설계, 구현에 이르기까지 도메인 모델의 기본적인 형태는 유지된다.  

* 표현적 차이 (representation gap)  
  * 의미적 차이 (semantic gap)
  * 도메인에 관한 정신적 모델과 소프트웨어 모델 간의 차이  
  
#### 소프트웨어 모델, 즉 코드가 도메인 모델을 떠오르게 하고,
#### 도메인 모델을 바탕으로 예측가능한 방식으로 작동할 경우  
#### "두 모델 간 표현적 차이가 적다."고 표현  

## **Domain-Driven Design**  
> 두 모델 간 표현적 차이를 최소화하기 위한 접근 방법  

EJB와 같은 구현 기술이 소프트웨어 개발을 주도함으로써 여러 가지 문제점 발생
#### 기술 주도적인 방식이 아닌 도메인 주도적인 방식으로 소프트웨어를 개발을 주장

### **Domain-Driven Design**의 조건  

* **UBIQUITOUS LANGUAGE**  
  * 고객과 개발자들 사이에 공통된 용어를 사용하도록 함  
  * 고객과 개발자들이 용어를 협의하고, 소프트웨어에 고객의 용어를 반영하는 과정
> 의사소통 issue로 인한 잘못된 소프트웨어 개발 방지  

* **MODEL-DRIVEN DESIGN**  
#### 분석, 설계, 구현의 모든 단계를 관통하는 하나의 모델을 만들자  
> 표현적 차이를 줄임으로써 소프트웨어가 도메인의 모습을 투영하도록  

  * 표현적 차이가 적은 객체-지향 언어를 사용  
    > 객체-지향적인 개발이 중요  
    
  * 비침투적인 POJO(Plain Old Java Object) 기반 경량 프레임워크 적용  
    > EJB와 같은 침투적인 인프라 스트럭처 지양  
    
### Domain-Driven Design을 위한 Next Step  
#### 관계형 데이터 베이스 도입에도 변경없이 도메인 모델의 핵심 구조를 유지

**ENTITY**부터 
