# [Domain-Driven Design의 적용 - 4.ORM과 투명한 영속성 3부](http://aeternum.egloos.com/1386122)

## ENTITY의 생명주기  

### 도메인 객체의 생명주기  

* 구현 기술에 종속적인 시각  
: 도메인 객체의 생명주기를 데이터베이스와의 상호작용을 중심으로 생각  
  * TRANSACTION SCRIPT 패턴 기반 어플리케이션  
  - 퍼시스턴스 메커니즘으로 JDBC를 직접 사용하는 방식  
    * 도메인 로직은 TRANSACTION SCRIPT 내에 절차적 방식을 구현  
    * 도메인 개념들은 getter/setter만을 가지는 Anemic Domain Model로 구성  
      > 상태는 가지지만, 행위는 포함하지 않는다.  
      > 구조체, 맵 수준의 역할만 => 단순히 레이어 간 데이터 전달을 위한 가짜 객체  
      ```
      정보를 데이터베이스에 저장하기 위해 
      속성이 설정된 도메인 객체를 생성하고, JDBC API를 사용하여 데이터베이스에 정보를 저장한 후  
      도메인 객체를 가비지 컬렉터에 넘겨 소멸시킨다.
      
      데이터베이스에 저장된 데이터가 필요한 경우  
      JDBC API를 사용하여 쿼리를 실행하고 
      새로운 도메인 객체를 생성한 후 반환된 결과 셋을 도메인 객체로 변환
      사용이 종료된 도메인 객체는 가비지 컬렉터에 넘겨져 소멸된다.
      ```
      
  * 도메인 객체들의 생명주기가 데이터베이스와의 상호작용 관점에서 파악
    * 도메인 개념의 **유일성, 추적성**은 구현 기술에 매몰되 의미를 상실한다.  
    * 도메인 객체는 단지 데이터베이스 테이블 구조를 반영한 메모리 저장소 역할만

* **ENTITY 관점**  
**도메인 분석 시에 발견된 연속성과 추적성을**  
**그대로 구현 레벨에 반영하기 위한 발상의 전환을 가져옴**  
  * 고객이 신규 가입한 경우 시스템에는 새로운 고객 정보를 가지는 새로운 ENTITY가 생성  
  * 고객 ENTITY는 잠시 메모리 객체의 형태로 시스템 내에 존재한다.  
  * 비즈니스 로직을 처리한 후 고객 ENTITY는 DB 레코드 형태로 존재한다.  
  * 다른 비즈니스 로직이 같은 고객 정보를 필요로 할 경우  
    해당 고객 ENTITY는 다시 메모리 객체로 형태를 바꿔 비즈니스 로직을 처리한다.  
  * 고객이 탈퇴를 하는 경우에만 해당 고객의 ENTITY 정보는 소멸한다.  
> 단순한 데이터 저장소, 포맷 개념이 아닌  
> 전체 시스템, 비즈니스 전체에서 사용을 위해 표현적 차이를 줄인 개념 (유일성, 추적성)  

### 표현적 차이를 줄이려면 ...
#### 도메인을 시스템 개발의 주도적 위치로 격상시키기 위해서는
#### 도메인 객체를 ENTITY의 개념에서 바라볼 필요가 있다.
* REPOSITORY  
> REPOSITORY는 도메인 객체를 ENTITY 개념으로 바라보기 위한 분석/설계를 위한 도구  

* REPOSITORY 개념을 적용한 ENTITY 생명주기 시나리오  
```
<고객이 신규 주문을 입력한 경우>
OrderRepository는 새로운 Order ENTITY를 내부적으로 등록하고 관리한다.

<저장된 Order가 필요한 경우>
클라이언트는 OrderRepository에 저장된 Order ENTITY를 찾아달라고 요청한다.
OrderRepository는 관리하고 있던 Order ENTITY를 찾아 반환한다.

<고객이 주문을 취소한 경우>
등록된 Order ENTITY가 더 이상 필요하지 않으므로
OrderRepository에게 해당 Order ENTITY를 제거하라고 요청한다.
OrderRepository는 해당 Order ENTITY를 제거한다.
```
  * Order ENTITY는 새로운 주문 정보가 추가되는 시점에 단 한 번 생성  
  * 이후 항상 동일한 Order ENTITY가 동일한 주문 정보를 표현  
  * 실제 도메인에서 해당 주문 정보가 사라지는 시점에 Order ENTITY도 소멸된다.  
    > Order ENTITY의 생명주기가 실제 도메인 내에서 일어나는 주문의 생명주기와 일치한다.  
  * Order ENTITY의 생명주기 중간에 새로운 객체가 생성된다는 개념은 없다.  
    > 단지 REPOSITORY에 의해 이미 등록된 Order ENTITY를 REPOSITORY를 통해 찾았을 뿐이다.  
    
* REPOSITORY 개념의 역할  
REPOSITORY는 ENTITY의 생성과 소멸 시점 사이를 책임지는 생명주기 관리 객체이다.  
// REPOSITORY는 아래 전제조건을 보장함으로써  
// 우리의 관점을 도메인에만 집중할 수 있게 돕는다.  

  * ENTITY의 *유일성* 보장  
    > 우리는 REPOSITORY를 통해 동일한 ENTITY를 얻을 수 있다.  
  * 시스템 전체의 복잡성을 낮춤  
    > 시스템의 모든 부분이 REPOSITORY를 통해 ENTITY에 접근한다.  
    * 변경된 ENTITY 정보는 시스템 전체에 전파된다.  
    * 도메인 객체들이 메모리 내에서 관리되는 것 같은 착각  
    
#### 도메인 레이어는 REPOSITORY가 실제로 ENTITY를 어떻게 관리하는지 상관없다.
> (메모리, 데이터베이스, XML 파일 ...)  
#### REPOSITORY는 내부 구현을 캡슐화함으로써 도메인 레이어에
#### 객체 지향적인 컬렉션 관리 인터페이스를 제공한다.
> 인터페이스를 통한 캡슐화의 힘  
> 도메인 모델에 REPOSITORY 개념을 도입한 결과로 얻게 되는 추상화의 장점  
  > Spring 같은 비침투적인 인프라 스트럭처의 도움을 받아 실제 구현을 편하게 할 수 있다.  

### 새로운 식별자의 개념  
#### 다양한 형태로 옷을 갈아 입는 ENTITY의 특성을 고려하는 순간 새로운 식별자의 개념이 필요해진다.  
> 메모리 주소를 비교하는 "==" 연산자의 한계  
